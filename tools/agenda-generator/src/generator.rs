use anyhow::{anyhow, Result};
use reqwest::header::{AUTHORIZATION, USER_AGENT};
use serde::de::{DeserializeOwned, Deserializer};
use serde::Deserialize;
use std::collections::{BTreeMap, BTreeSet};
use std::fmt::Write;
use itertools::Itertools;

#[derive(Default)]
pub struct Generator {
    agenda: String,
    seen: BTreeSet<String>,
}

impl Generator {
    pub fn libs_api_agenda(mut self) -> Result<String> {
        writeln!(
            &mut self.agenda,
            "# Libs-API Meeting {}

###### tags: `Libs Meetings` `Minutes`

**Attendees**: ...

## Agenda

- [Open action items](https://hackmd.io/ovrbJj6CRduRgSA0Wzg2zg)
- Triage
- Anything else?

## Triage
",
            chrono::Utc::now().format("%Y-%m-%d")
        )?;

        self.fcps()?;

        IssueQuery::new("Nominated")
            .labels(&["T-libs-api", "I-nominated"])
            .repo("rust-lang/libs-team")
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Waiting on team")
            .labels(&["T-libs-api", "S-waiting-on-team"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Needs decision")
            .labels(&["T-libs-api", "I-needs-decision"])
            .repo("rust-lang/rust")
            .write(&mut self)?;

        writeln!(&mut self.agenda,
        "## Actions

- [ ] Reply to all issues/PRs discussed in this meeting, or add them to the [open action items](https://hackmd.io/ovrbJj6CRduRgSA0Wzg2zg).
"
    )?;

        writeln!(&mut self.agenda, "_Generated by [fully-automatic-rust-libs-team-triage-meeting-agenda-generator](https://github.com/rust-lang/libs-team/tree/main/tools/agenda-generator)_")?;
        Ok(self.agenda)
    }

    pub fn libs_agenda(mut self) -> Result<String> {
        writeln!(
            &mut self.agenda,
            "# Libs Meeting {}

###### tags: `Libs Meetings` `Minutes`

**Attendees**: ...

## Agenda

- Triage
    - Critical Issues
    - MCPs
- Anything else?

## Triage
",
            chrono::Utc::now().format("%Y-%m-%d")
        )?;

        IssueQuery::new("Critical")
            .labels(&["T-libs", "P-critical"])
            .labels(&["T-libs-api", "P-critical"])
            .labels(&["T-libs", "I-unsound"])
            .labels(&["T-libs-api", "I-unsound"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Regressions")
            .labels(&["T-libs", "regression-untriaged"])
            .labels(&["T-libs-api", "regression-untriaged"])
            .labels(&["T-libs", "regression-from-stable-to-stable"])
            .labels(&["T-libs-api", "regression-from-stable-to-stable"])
            .labels(&["T-libs", "regression-from-stable-to-beta"])
            .labels(&["T-libs-api", "regression-from-stable-to-beta"])
            .labels(&["T-libs", "regression-from-stable-to-nightly"])
            .labels(&["T-libs-api", "regression-from-stable-to-nightly"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Backports")
            .labels(&["T-libs", "stable-nominated"])
            .labels(&["T-libs-api", "stable-nominated"])
            .labels(&["T-libs", "stable-accepted"])
            .labels(&["T-libs-api", "stable-accepted"])
            .labels(&["T-libs", "beta-nominated"])
            .labels(&["T-libs-api", "beta-nominated"])
            .labels(&["T-libs", "beta-accepted"])
            .labels(&["T-libs-api", "beta-accepted"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Prioritization Requested")
            .labels(&["T-libs", "I-prioritize"])
            .labels(&["T-libs-api", "I-prioritize"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        IssueQuery::new("Bugs")
            .labels(&["T-libs", "C-bug"])
            .labels(&["T-libs-api", "C-bug"])
            .repo("rust-lang/rust")
            .repo("rust-lang/rfcs")
            .write(&mut self)?;

        writeln!(&mut self.agenda,
        "## Actions

- [ ] Reply to all issues/PRs discussed in this meeting, or add them to the [open action items](https://hackmd.io/ovrbJj6CRduRgSA0Wzg2zg).
"
    )?;

        writeln!(&mut self.agenda, "_Generated by [fully-automatic-rust-libs-team-triage-meeting-agenda-generator](https://github.com/rust-lang/libs-team/tree/main/tools/agenda-generator)_")?;
        Ok(self.agenda)
    }

    fn fcps(&mut self) -> Result<()> {
        let p = reqwest::blocking::get("https://rfcbot.rs")?.text()?;
        let mut p = p.lines();
        p.find(|s| s.trim_end() == "<h4><code>T-libs-api</code></h4>")
            .ok_or_else(|| anyhow!("Missing T-libs-api section"))?;

        let mut fcps = BTreeMap::<&str, Vec<Fcp>>::new();
        let mut reviewer_count: BTreeMap<&str, usize> = [
            "Amanieu",
            "BurntSushi",
            "dtolnay",
            "joshtriplett",
            "m-ou-se",
            "sfackler",
            "yaahc",
        ]
        .iter()
        .map(|&r| (r, 0))
        .collect();

        loop {
            let line = p.next().unwrap();
            if line.starts_with("<h4>") || line.starts_with("</html>") {
                break;
            }
            if line.trim() == "<li>" {
                let disposition = p.next().unwrap().trim().strip_suffix(':').unwrap();
                let url = p
                    .next()
                    .unwrap()
                    .trim()
                    .strip_prefix("<b><a href=\"")
                    .unwrap()
                    .strip_suffix('"')
                    .unwrap();
                assert_eq!(p.next().unwrap().trim(), "target=\"_blank\">");
                let title_and_number = p.next().unwrap().trim().strip_suffix(")</a></b>").unwrap();
                let (title, number) = title_and_number.rsplit_once(" (").unwrap();
                let (repo, number) = number.split_once('#').unwrap();
                let mut reviewers = Vec::new();
                let mut concerns = false;
                loop {
                    let line = p.next().unwrap().trim();
                    if line == "</li>" {
                        break;
                    }
                    if line == "pending concerns" {
                        concerns = true;
                    } else if let Some(line) = line.strip_prefix("<a href=\"/fcp/") {
                        let reviewer = line.split_once('"').unwrap().0;
                        if let Some(n) = reviewer_count.get_mut(reviewer) {
                            reviewers.push(reviewer);
                            *n += 1;
                        }
                    }
                }
                fcps.entry(repo).or_default().push(Fcp {
                    title,
                    repo,
                    number,
                    disposition,
                    url,
                    reviewers,
                    concerns,
                });
            }
        }

        writeln!(self.agenda, "### FCPs")?;
        writeln!(self.agenda,)?;
        writeln!(
            self.agenda,
            "{} open T-libs-api FCPs:",
            fcps.values().map(|v| v.len()).sum::<usize>()
        )?;
        for (repo, fcps) in fcps.iter() {
            writeln!(self.agenda, "<details><summary><a href=\"https://github.com/{}/issues?q=is%3Aopen+label%3AT-libs-api+label%3Aproposed-final-comment-period\">{} <code>{}</code> FCPs</a></summary>\n", repo, fcps.len(), repo)?;
            for fcp in fcps {
                write!(
                    self.agenda,
                    "  - [[{} {}]({})] *{}*",
                    fcp.disposition,
                    fcp.number,
                    fcp.url,
                    escape(fcp.title)
                )?;
                writeln!(self.agenda, " - ({} checkboxes left)", fcp.reviewers.len())?;
                if fcp.concerns {
                    writeln!(self.agenda, "    Blocked on an open concern.")?;
                }
            }
            writeln!(self.agenda, "</details>")?;
        }
        writeln!(self.agenda, "<p></p>\n")?;

        for (i, (&reviewer, &num)) in reviewer_count.iter().enumerate() {
            if i != 0 {
                write!(self.agenda, ", ")?;
            }
            write!(
                self.agenda,
                "[{} ({})](https://rfcbot.rs/fcp/{})",
                reviewer, num, reviewer
            )?;
        }
        writeln!(self.agenda,)?;
        writeln!(self.agenda,)?;

        Ok(())
    }

    fn write_issues(&mut self, issues: &[Issue]) -> Result<()> {
        for issue in issues.iter().rev() {
            writeln!(
                self.agenda,
                "  - [[{}]({})] *{}*",
                issue.number,
                issue.html_url,
                escape(&issue.title)
            )?;
            if issue
                .labels
                .iter()
                .any(|l| l == "finished-final-comment-period")
            {
                write!(self.agenda, "    FCP finished.")?;
                for label in issue.labels.iter() {
                    if let Some(disposition) = label.strip_prefix("disposition-") {
                        write!(self.agenda, " Should be {}d?", disposition)?;
                    }
                }
                writeln!(self.agenda,)?;
            }
        }

        Ok(())
    }

    fn dedup(&mut self, mut issues: Vec<Issue>) -> Vec<Issue> {
        issues.retain(|issue| self.seen.insert(issue.html_url.clone()));
        issues
    }
}

struct IssueQuery {
    name: &'static str,
    labels: Vec<&'static [&'static str]>,
    repos: Vec<&'static str>,
}

impl IssueQuery {
    fn new(name: &'static str) -> Self {
        Self {
            name,
            labels: vec![],
            repos: vec![],
        }
    }

    fn labels(&mut self, labels: &'static [&'static str]) -> &mut Self {
        self.labels.push(labels);
        self
    }

    fn repo(&mut self, repo: &'static str) -> &mut Self {
        self.repos.push(repo);
        self
    }

    fn write(&mut self, generator: &mut Generator) -> Result<()> {
        writeln!(generator.agenda, "### {}", self.name)?;
        writeln!(generator.agenda,)?;

        for repo in &self.repos {
            for labels in &self.labels {
                let cs_labels = labels.join(",");
                let endpoint = format!("repos/{}/issues?labels={}", repo, cs_labels);
                let issues = generator.dedup(github_api(&endpoint)?);

                if issues.is_empty() {
                    continue;
                }

                let url_labels = labels.iter().map(|label| format!("label:{}", label)).join("+");
                writeln!(
                    generator.agenda,
                    "- [{} `{repo}` items](https://github.com/{repo}/issues?q=is:open+{url_labels})",
                    issues.len(),
                    repo = repo,
                    url_labels = url_labels
                )?;
                generator.write_issues(&issues)?;
            }
        }

        writeln!(generator.agenda,)?;

        Ok(())
    }
}

#[derive(Debug)]
struct Fcp<'a> {
    title: &'a str,
    repo: &'a str,
    number: &'a str,
    disposition: &'a str,
    url: &'a str,
    reviewers: Vec<&'a str>,
    concerns: bool,
}

#[derive(Debug, Deserialize)]
struct Issue {
    number: u32,
    html_url: String,
    title: String,
    #[serde(deserialize_with = "deserialize_labels")]
    labels: Vec<String>,
}

fn escape(v: &str) -> String {
    let mut s = String::with_capacity(v.len() + 10);
    v.chars().for_each(|c| {
        match c {
            '_' | '*' | '\\' | '[' | ']' | '-' | '<' | '>' | '`' => s.push('\\'),
            _ => {}
        }
        s.push(c);
    });
    s
}

fn github_api<T: DeserializeOwned>(endpoint: &str) -> Result<T> {
    let mut client = reqwest::blocking::Client::new()
        .get(&format!("https://api.github.com/{}", endpoint))
        .header(USER_AGENT, "rust-lang libs agenda maker");
    if let Ok(token) = std::env::var("GITHUB_TOKEN") {
        client = client.header(AUTHORIZATION, format!("token {}", token));
    }
    let response = client.send()?;
    // dbg!(response.text());
    // panic!();
    Ok(response.json()?)
}

fn deserialize_labels<'de, D: Deserializer<'de>>(d: D) -> Result<Vec<String>, D::Error> {
    #[derive(Debug, Deserialize)]
    struct Label {
        name: String,
    }
    let v = Vec::<Label>::deserialize(d)?;
    Ok(v.into_iter().map(|l| l.name).collect())
}
